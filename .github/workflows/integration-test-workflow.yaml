name: Integration Test Workflow

concurrency:
  group: ${{ github.ref }}-${{ inputs.registry }}
  cancel-in-progress: true

permissions:
  contents: read # access to check out code and install dependencies for python (wasmopticon tests)
  actions: read

on:
  workflow_call:
    inputs:
      fetch_artifact:
        required: false
        type: string
        description: "Set to the name of the wasmer artifact you'd like to fetch and use in the integration tests."
      test_branch:
        required: false
        type: string
        description: "Checkout a specific branch of the integration tests"
        default: "main"
      registry:
        required: false
        type: string
        description: Which registry to target, which also choses which environment to test
        default: wasmer.wtf
      provide_quality_assessment:
        required: false
        type: boolean
        description: Set to true if you'd like to print integration test results in test_failure_webhook
      release_url:
        required: false
        type: string
        description: "Optional URL of the release that triggered these tests"
    secrets:
      token:
        required: true
        description: "Token used to authenticate towards the wasmer backend"
      test_failure_webhook:
        required: false
        description: "Add optional webhook which will be called if any tests have failed"

jobs:
  test-suites:
    name: Run ${{ matrix.id }} tests
    runs-on: ubuntu-24.04
    timeout-minutes: ${{ matrix.timeout_minutes || 15 }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - id: general
            test_command: |
              npx jest ./tests/general/
          - id: jobs
            test_command: |
              npx jest ./tests/validation/log.test.ts
              npx jest ./tests/job
          - id: wordpress
            test_command: |
              npx jest ./tests/validation/log.test.ts
              npx jest ./tests/wordpress
          - id: ssh
            test_command: |
              npx jest ./tests/ssh
          - id: deploy
            test_command: |
              npx jest ./tests/deploy
          - id: wasmopticon
            test_command: |
              npx jest tests/wasmopticon
            requires_python: true
            python_version: "3.13"

    steps:
      - name: Clone repository
        uses: actions/checkout@v4
        with:
          repository: wasmerio/wasmer-integration-tests
          ref: ${{ inputs.test_branch }}
          submodules: true
      # The relative path works here as we're checking out the wasmer-integration-tests repo
      - uses: ./.github/actions/setup-test-env
        with:
          fetch_artifact: ${{ inputs.fetch_artifact }}
      - name: Set up Python
        if: ${{ matrix.requires_python == true }}
        uses: actions/setup-python@v6
        with:
          python-version: ${{ matrix.python_version }}
      - name: Install uv
        if: ${{ matrix.requires_python == true }}
        uses: astral-sh/setup-uv@v6
        with:
          python-version: ${{ matrix.python_version }}
      - name: Setup and activate virtual environment
        if: ${{ matrix.requires_python == true }}
        run: |
          python -m venv .venv
          source .venv/bin/activate
      - name:
          Debug: check WASMER_TOKEN
        env:
          WASMER_TOKEN: ${{ secrets.token }}
        run: |
          [ -n "$WASMER_TOKEN" ] && echo "set" || echo "not set"
          wasmer whoami
      - name: Test
        env:
          WASMER_REGISTRY: https://registry.${{ inputs.registry }}/graphql
          WASMER_TOKEN: ${{ secrets.token }}
        run: |
          ${{ matrix.test_command }}
      - name: Notify failure in Slack
        env:
          TEST_FAILURE_WEBHOOK: ${{ secrets.test_failure_webhook }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        if: failure() && env.TEST_FAILURE_WEBHOOK != ''
        run: |
          jobs=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id}}/attempts/${{ github.run_attempt }}/jobs)
          job_id=$(echo $jobs | jq -r '.jobs[] | select(.runner_name=="${{ runner.name }}") | .id')
          text="Integration tests for ${{ matrix.id }} failed ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}/job/$job_id"
          payload=$(jq -n --arg text "$text" '{text: $text}')
          curl -X POST \
            -H 'Content-type: application/json' \
            --data "$payload" \
            ${TEST_FAILURE_WEBHOOK}

  provide-quality-assessment:
    name: Provide quality assessment
    if: ${{ inputs.provide_quality_assessment == true }}
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    steps:
      - name: Wait for failures
        id: fail
        uses: actions/github-script@v8
        with:
          script: |
            const o = context.repo.owner;
            const r = context.repo.repo;
            const id = context.runId;
            function isSelf(job) {
              if (job.name === 'Notify quality assessment') return true;
              if (job.name === 'notify-quality-assessment') return true;
              if (job.name === context.job) return true;
              if (job.name === process.env.GITHUB_JOB) return true;
              return (job.steps || []).some(
                step => step.name === 'Wait for failures'
              );
            }
            const filterJobs = js =>
              js.filter(job => !isSelf(job));
            async function jobs() {
              const res = await github.rest.actions
                .listJobsForWorkflowRun({
                  owner: o, repo: r, run_id: id
                });
              return res.data.jobs || [];
            }
            async function waitDone() {
              // This equates to 180*5000ms = 15 minutes
              for (let i = 0; i < 180; i++) {
                const js = await jobs();
                const others = filterJobs(js);
                const done = others.every(
                  j => j.status === 'completed'
                );
                if (done) return others;
                await new Promise(x => setTimeout(x, 5000));
              }
              return filterJobs(await jobs());
            }
            const all = await waitDone();
            const failed = all.filter(
              j => j.conclusion === 'failure'
            );
            core.setOutput('count', String(failed.length));
            core.setOutput('jobs', JSON.stringify(
              failed.map(j => ({
                id: j.id, name: j.name, url: j.html_url
              }))
            ));
      - name: Get commit info
        id: ci
        uses: actions/github-script@v8
        with:
          script: |
            const o = context.repo.owner;
            const r = context.repo.repo;
            const pr = context.payload.pull_request;
            const sha = pr ? pr.head.sha : context.sha;
            const ref = pr ? pr.head.ref : context.ref;
            const cm = await github.rest.repos.getCommit({
              owner: o, repo: r, ref: sha
            });
            const c = cm.data.commit;
            const url = 'https://github.com/' + o + '/'
              + r + '/commit/' + sha;
            core.setOutput('sha', sha);
            core.setOutput('ref', ref);
            core.setOutput('author', c.author.name);
            core.setOutput('email', c.author.email);
            core.setOutput('message', c.message);
            core.setOutput('url', url);
            core.setOutput('is_pr', pr ? 'true' : 'false');
            core.setOutput('pr_num', pr ? String(pr.number) : '');
            core.setOutput('repository', o + '/' + r);
      - name: Compose notification
        id: notify
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.test_failure_webhook }}
          FAILURE_COUNT: ${{ steps.fail.outputs.count }}
          SHA: ${{ steps.ci.outputs.sha }}
          AUTHOR: ${{ steps.ci.outputs.author }}
          EMAIL: ${{ steps.ci.outputs.email }}
          REF: ${{ steps.ci.outputs.ref }}
          URL: ${{ steps.ci.outputs.url }}
          MESSAGE: ${{ steps.ci.outputs.message }}
          REPO: ${{ steps.ci.outputs.repository }}
          RELEASE_URL: ${{ inputs.release_url || github.event.release.html_url || '' }}
        run: |
          set -euo pipefail
          short_sha="${SHA:0:7}"
          ref_label="${REPO}@${REF}"
          send="true"
          if [ -z "${SLACK_WEBHOOK_URL}" ]; then
            send="false"
          fi
          release_line="${RELEASE_URL:+*Release:* ${RELEASE_URL}}"
          if [ "${FAILURE_COUNT}" = "0" ]; then
            msg_lines=(
              'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'
              "ğŸ‰ All green from update in *${REPO}*! Good job *${AUTHOR}*! ğŸ™Œ"
              ''
              "*Repository:* ${REPO}"
            )
            msg_lines+=(
              "*Commit:* <${URL}|${short_sha}>"
              ''
              '*Commit message:*'
              '```'
              "${MESSAGE}"
              '```'
            )
            printf -v text '%s\n' "${msg_lines[@]}"
            conclusion="success"
          else

            usernameFromEmail="${EMAIL%@*}"
            
            # Some manually mapped common cases
            case "${EMAIL}" in
              "me@syrusakbary.com")
                usernameFromEmail="syrus"
                ;;
              "artem.yarulin@kapteko.com")
                usernameFromEmail="artem"
                ;;
              "33205668+riverzaw@users.noreply.github.com"|"riverzaw@fastmail.com")
                usernameFromEmail="irina"
                ;;
              "chris@theduke.at")
                usernameFromEmail="christoph"
              ;;

            esac

            msg_lines=(
              "*Uh-oh, what happened here?â˜ï¸ *"
              "Seems like something broke... Who dunit'?"
              "Primary suspect: *<@${usernameFromEmail}>*"
              ''
              "*Commit:* ${SHA}, <${URL}|View commit>"
              ''
              "*Repository:* ${REPO}"
            )
            if [ -n "${release_line}" ]; then
              msg_lines+=("${release_line}")
            fi
            msg_lines+=(
              '*Commit message:*'
              '```'
              "${MESSAGE}"
              '```'
              'Recommendation: Re-run the failing pipeline in case of flaky test/flaky functionality.'
            )
            printf -v text '%s\n' "${msg_lines[@]}"
            conclusion="failure"
          fi
          payload=$(jq -n --arg text "$text" '{text: $text}')
          {
            echo "text<<EOF"
            printf '%s\n' "$text"
            echo "EOF"
            echo "payload<<EOF"
            printf '%s\n' "$payload"
            echo "EOF"
            echo "conclusion=$conclusion"
            echo "send=$send"
          } >> "$GITHUB_OUTPUT"
      - name: Post Slack message
        if: ${{ steps.notify.outputs.send == 'true' }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.test_failure_webhook }}
          PAYLOAD: ${{ steps.notify.outputs.payload }}
        run: |
          set -euo pipefail
          curl -sS -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" "$SLACK_WEBHOOK_URL"
      - name: Write job summary
        if: ${{ steps.notify.outputs.conclusion == 'failure' }}
        env:
          SUMMARY_TEXT: ${{ steps.notify.outputs.text }}
        run: |
          printf '%s\n' "$SUMMARY_TEXT" >> "$GITHUB_STEP_SUMMARY"
